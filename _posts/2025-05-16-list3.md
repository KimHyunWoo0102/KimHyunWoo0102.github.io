---
layout: single
title:  "ìë£Œêµ¬ì¡° - ë¦¬ìŠ¤íŠ¸3: ArrayList ì •ì˜"
categories: c++ ìë£Œêµ¬ì¡° (ì¤‘ë‹¨)
tag: [c++, data_structure]
toc: true
author_profile: false
classes: wide
typora-root-url: ../
---

# ğŸ¯ ëª©í‘œ

ìë£Œêµ¬ì¡° ë³µìŠµì—ì„œ ê°€ì¥ ì¤‘ìš”í•˜ê²Œ ìƒê°í•œ ë¶€ë¶„ì€ **í´ë˜ìŠ¤ë¡œ êµ¬í˜„í•˜ê³  ì´ë¥¼ ì˜ í™œìš©í•˜ëŠ” ê²ƒ**ì´ì—ˆìŠµë‹ˆë‹¤.  
ì´ë¥¼ ìœ„í•´ `List`ë¥¼ ì¸í„°í˜ì´ìŠ¤ë¡œ ë¨¼ì € ì •ì˜í–ˆê³ , ì´ë²ˆ ê¸€ì—ì„œëŠ” **ë°°ì—´ ê¸°ë°˜ ë¦¬ìŠ¤íŠ¸ì¸ `ArrayList`**ë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤.

---

# ğŸ§± ArrayList êµ¬í˜„

## ğŸ’» ì½”ë“œ

### ğŸ“„ `CArrayList.h`

```cpp
#pragma once
#include "IList.h"
#include "Exception.h"
#include <vector>

constexpr size_t NOT_FOUND = -1;

template<typename T>
class CArrayList : public IList<T>
{
public:
    explicit CArrayList(const size_t& max_allocation)
        : _max_allocation(max_allocation), _current_index(0)
    {
        _arr = new T[max_allocation];
    }
    ~CArrayList() { delete[] _arr; }

    size_t size() override { return _current_index; }
    bool isEmpty() override { return _current_index == 0; }

    const std::vector<T> getElements() const override;
    const T& get(int rank) override;

    void append(int rank, const T& element) override;
    const T& remove(int rank) override;
    const size_t search(const T& element) override;

private:
    size_t _max_allocation;
    size_t _current_index;
    T* _arr;
};

template<typename T>
const std::vector<T> CArrayList<T>::getElements() const
{
    std::vector<T> ret;
    for (size_t i = 0; i < _current_index; ++i) {
        ret.push_back(_arr[i]);
    }
    return ret;
}

template<typename T>
const T& CArrayList<T>::get(int rank)
{
    if (rank < 0 || rank >= static_cast<int>(_current_index))
        throw InvalidRankException(__func__);
    return _arr[rank];
}

template<typename T>
void CArrayList<T>::append(int rank, const T& element)
{
    if (_current_index >= _max_allocation)
        throw FullListException(__func__);

    if (rank < 0 || rank > static_cast<int>(_current_index))
        throw InvalidRankException(__func__);

    for (int i = static_cast<int>(_current_index) - 1; i >= rank; --i) {
        _arr[i + 1] = _arr[i];
    }

    _arr[rank] = element;
    _current_index++;
}

template<typename T>
const T& CArrayList<T>::remove(int rank)
{
    if (rank < 0 || rank >= static_cast<int>(_current_index))
        throw InvalidRankException(__func__);

    const T e = _arr[rank];

    for (size_t i = rank; i < _current_index - 1; ++i) {
        _arr[i] = _arr[i + 1];
    }
    _current_index--;

    return e;
}

template<typename T>
const size_t CArrayList<T>::search(const T& element)
{
    if (isEmpty())
        return NOT_FOUND;

    for (size_t i = 0; i < _current_index; ++i) {
        if (_arr[i] == element)
            return i;
    }

    return NOT_FOUND;
}
```



# ğŸ§© IList ìˆ˜ì •

### ğŸ“„ `IList.h`

```
cppë³µì‚¬í¸ì§‘friend std::ostream& operator<<(std::ostream& os, const IList<T>& list) {
    list.print(os);  // ìì‹ í´ë˜ìŠ¤ê°€ êµ¬í˜„í•œ print() í˜¸ì¶œë¨
    return os;
}

template<typename T>
inline void IList<T>::print(std::ostream& os) const
{
    const auto elements = this->getElements();
    os << "[";
    for (const auto& it : elements) {
        os << it << ", ";
    }
    os << "]";
}
```

## âœ¨ ì´ìœ 

`operator<<`ì„ `IList` ë‚´ë¶€ì— ë©¤ë²„ í•¨ìˆ˜ë¡œ ì •ì˜í•˜ë ¤ê³  í–ˆì§€ë§Œ **ë©¤ë²„ í•¨ìˆ˜ì¼ ê²½ìš° `std::cout << obj;` í˜•ì‹ì´ ë¶ˆê°€ëŠ¥**í•©ë‹ˆë‹¤.

- `std::cout << value`ëŠ” `std::cout.operator<<(value)`ì™€ ê°™ìŒ
- ë”°ë¼ì„œ ë©¤ë²„ í•¨ìˆ˜ë¡œ ì •ì˜í•˜ë©´ `obj.operator<<(value)`ì²˜ëŸ¼ `obj`ê°€ ì™¼ìª½ì— ì™€ì•¼ í•¨
- ìš°ë¦¬ê°€ ì›í•˜ëŠ” ë°©ì‹ì€ `std::cout << obj;`ì´ë¯€ë¡œ **ì „ì—­ friend í•¨ìˆ˜**ë¡œ ì„ ì–¸í•´ì•¼ í•¨

ğŸ“Œ ì´ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ `print()` í•¨ìˆ˜ë¡œ ì¶œë ¥ ë¡œì§ì„ ë„˜ê¸°ê³  `operator<<`ì—ì„œëŠ” ì´ë¥¼ í˜¸ì¶œí•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ì²˜ë¦¬í–ˆìŠµë‹ˆë‹¤.

------



# ğŸ§ª í…ŒìŠ¤íŠ¸ ì½”ë“œ ìˆ˜ì •

ê¸°ì¡´ì—ëŠ” í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ë²¡í„°ë¥¼ ì§ì ‘ ì°¸ì¡°í•˜ë‹¤ ë³´ë‹ˆ, ë¦¬ìŠ¤íŠ¸ì—ì„œ ìš”ì†Œë¥¼ ì œê±°í•œ í›„ ê°’ì´ ì¼ì¹˜í•˜ì§€ ì•ŠëŠ” ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.
 â†’ **ë¦¬ìŠ¤íŠ¸ì˜ ë³µì‚¬ë³¸ì„ ë¨¼ì € ë§Œë“¤ì–´ë‘ê³  ì´ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ê²€ì¦**í•˜ë„ë¡ ìˆ˜ì •í–ˆìŠµë‹ˆë‹¤.

### ğŸ“„ `ListTest.h` - `testListRemove()` ìˆ˜ì •

```
cppë³µì‚¬í¸ì§‘template<typename T>
inline void ListTester<T>::testListRemove()
{
    std::vector<T> listCopy = _list.getElements();

    T removedFirst = _list.remove_first();
    if (removedFirst != listCopy[0])
        throw RemoveFailureException(__func__, "Failed to remove element from the front correctly.");
    std::cout << _list << "\n";

    listCopy.erase(listCopy.begin());
    if (_list.size() != listCopy.size() || _list.get(0) != listCopy[0])
        throw RemoveFailureException(__func__, "List mismatch after removing from the front.");

    T removedLast = _list.remove_last();
    if (removedLast != listCopy.back())
        throw RemoveFailureException(__func__, "Failed to remove element from the back correctly.");
    std::cout << _list << "\n";

    listCopy.pop_back();
    if (_list.size() != listCopy.size() || _list.get(_list.size() - 1) != listCopy.back())
        throw RemoveFailureException(__func__, "List mismatch after removing from the back.");

    size_t middleIndex = _list.size() / 2;
    T removedMiddle = _list.remove(middleIndex);
    if (removedMiddle != listCopy[middleIndex])
        throw RemoveFailureException(__func__, "Failed to remove element from the middle correctly.");
    std::cout << _list << "\n";

    listCopy.erase(listCopy.begin() + middleIndex);
    if (_list.size() != listCopy.size() || _list.get(middleIndex) != listCopy[middleIndex])
        throw RemoveFailureException(__func__, "List mismatch after removing from the middle.");
}
```

------

# ğŸ§ª í…ŒìŠ¤íŠ¸ ì‹¤í–‰

### ğŸ“„ `main.cpp`

```
cppë³µì‚¬í¸ì§‘int main() {
    std::unique_ptr<IList<int>> list = std::make_unique<CArrayList<int>>(50); // ìµœëŒ€ í¬ê¸° 50

    std::vector<int> test_case{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    ListTester::ListTester<int> test(*list, test_case);

    test.TestList();

    return 0;
}
```

### ğŸ–¼ï¸ ê²°ê³¼

![test_result](/images/2025-05-16-list3/test_result.png)
